=== AETHERON STRUCTURE ===
/home/khryon/aetheron
â”œâ”€â”€ init-structure.sh
â”œâ”€â”€ scripts
â”‚Â Â  â”œâ”€â”€ common.sh
â”‚Â Â  â””â”€â”€ recover-mariadb-password.sh
â”œâ”€â”€ server-setup.sh
â”œâ”€â”€ services
â”‚Â Â  â”œâ”€â”€ anode
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ apache
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ add-subdomain.sh
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ cert-update.sh
â”‚Â Â  â”œâ”€â”€ cockpit
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ docker
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ letsencrypt
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ domains.conf
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ mariadb
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ mediawiki
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ netdata
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ nextcloud
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ postgresql
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ quasselcore
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ teamspeak
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â”œâ”€â”€ templates
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ reinstall.sh
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ uninstall.sh
â”‚Â Â  â”‚Â Â  â””â”€â”€ wipe.sh
â”‚Â Â  â”œâ”€â”€ unrealircd
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config.conf
â”‚Â Â  â”‚Â Â  â””â”€â”€ install.sh
â”‚Â Â  â””â”€â”€ vsftp
â”‚Â Â      â””â”€â”€ install.sh
â””â”€â”€ utility-scripts
    â”œâ”€â”€ aetheron-update
    â”œâ”€â”€ database-backup
    â”œâ”€â”€ overview.txt
    â”œâ”€â”€ raspberry-update.sh
    â”œâ”€â”€ reverse-proxy-install.sh
    â””â”€â”€ structure.sh

19 directories, 31 files

=== SERVER-SETUP.SH ===
#!/bin/bash
# server-setup.sh
# Version: 1.04.08

VERSION="1.04.08"
BASE_DIR=~/aetheron
SERVICES_DIR=$BASE_DIR/services
SCRIPTS_DIR=$BASE_DIR/scripts
LOG_DIR=$BASE_DIR/logs
mkdir -p "$LOG_DIR" "$SCRIPTS_DIR"
LOGFILE="$LOG_DIR/server-setup.log"
SUMMARY_LOG="$LOG_DIR/summary.last.log"

DRYRUN=false

# Load common functions
if [[ -f "$SCRIPTS_DIR/common.sh" ]]; then
    source "$SCRIPTS_DIR/common.sh"
else
    echo "ERROR: common.sh not found at $SCRIPTS_DIR/common.sh"
    echo "Please run init-structure.sh first to create the base structure."
    exit 1
fi

# Arrays fÃ¼r die Zusammenfassung
SUCCESSFUL_SERVICES=()
FAILED_SERVICES=()
SKIPPED_SERVICES=()

log_message "=== Aetheron Setup Script started ==="
log_message "Version: $VERSION"

show_status() {
    if $DRYRUN; then
        echo "[MODE] Running in TEST MODE (--dry-run)"
    else
        echo "[MODE] Running in NORMAL MODE"
    fi
    echo "[INFO] Script Version: $VERSION"
    
    # Firewall Status anzeigen
    if command -v firewall-cmd &> /dev/null; then
        local default_zone=$(sudo firewall-cmd --get-default-zone)
        local ssh_status=$(sudo firewall-cmd --list-services | grep -q ssh && echo "âœ…" || echo "âŒ")
        echo "[FIREWALL] Default Zone: $default_zone, SSH: $ssh_status"
    fi
}

print_summary() {
    local operation=$1
    clear
    echo "=============================="
    echo "         ZUSAMMENFASSUNG"
    echo "=============================="
    echo "Operation: $operation"
    echo "DurchgefÃ¼hrt am: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "Version: $VERSION"
    echo "=============================="
    echo ""

    if [ ${#SUCCESSFUL_SERVICES[@]} -gt 0 ]; then
        echo "âœ… ERFOLGREICH:"
        for service in "${SUCCESSFUL_SERVICES[@]}"; do
            echo "   - $service"
        done
        echo ""
    fi

    if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
        echo "âŒ FEHLGESCHLAGEN:"
        for service in "${FAILED_SERVICES[@]}"; do
            echo "   - $service"
            echo "     Log: $SERVICES_DIR/$service/logs/$operation.log"
        done
        echo ""
    fi

    if [ ${#SKIPPED_SERVICES[@]} -gt 0 ]; then
        echo "âš ï¸  ÃœBERSPRUNGEN:"
        for service in "${SKIPPED_SERVICES[@]}"; do
            echo "   - $service"
        done
        echo ""
    fi

    # Firewall-Status in Zusammenfassung
    if command -v firewall-cmd &> /dev/null; then
        echo "=============================="
        echo "ðŸ” FIREWALL STATUS"
        echo "=============================="
        echo "Default Zone: $(sudo firewall-cmd --get-default-zone)"
        echo "Active Services: $(sudo firewall-cmd --list-services)"
        echo "=============================="
        echo ""
    fi

    # Zusammenfassung in Datei schreiben
    {
        echo "Zusammenfassung vom $(date '+%Y-%m-%d %H:%M:%S')"
        echo "Version: $VERSION"
        echo "Operation: $operation"
        echo "Erfolgreich: ${#SUCCESSFUL_SERVICES[@]}"
        echo "Fehlgeschlagen: ${#FAILED_SERVICES[@]}"
        echo "Ãœbersprungen: ${#SKIPPED_SERVICES[@]}"
        echo ""
        
        if [ ${#SUCCESSFUL_SERVICES[@]} -gt 0 ]; then
            echo "Erfolgreiche Dienste:"
            for service in "${SUCCESSFUL_SERVICES[@]}"; do
                echo "  - $service"
            done
            echo ""
        fi
        
        if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
            echo "Fehlerhafte Dienste:"
            for service in "${FAILED_SERVICES[@]}"; do
                echo "  - $service"
                echo "    Log: $SERVICES_DIR/$service/logs/$operation.log"
            done
            echo ""
        fi

        # Firewall-Info in Logfile
        if command -v firewall-cmd &> /dev/null; then
            echo "FIREWALL INFO:"
            echo "Default Zone: $(sudo firewall-cmd --get-default-zone)"
            echo "Services: $(sudo firewall-cmd --list-services)"
            echo "Ports: $(sudo firewall-cmd --list-ports)"
        fi
    } > "$SUMMARY_LOG"

    # Kritische AbhÃ¤ngigkeiten warnung
    local critical_services=("mariadb")
    local has_critical_error=0
    
    for critical_service in "${critical_services[@]}"; do
        if printf '%s\n' "${FAILED_SERVICES[@]}" | grep -q "^${critical_service}$"; then
            echo "âš ï¸  WARNUNG: $critical_service ist fehlgeschlagen!"
            echo "   Viele Dienste benÃ¶tigen MariaDB fÃ¼r korrekte Funktion."
            has_critical_error=1
        fi
    done
    
    if [ $has_critical_error -eq 1 ]; then
        echo ""
        echo "â„¹ï¸  Empfehlung: Beheben Sie zuerst die Fehler bei den kritischen Diensten."
    fi
    
    echo "=============================="
}

run_service_action() {
    local action=$1
    local service=$2
    local original_service=$service

    # SpezialfÃ¤lle fÃ¼r Dienstgruppen
    case "$service" in
        "irc") 
            local services_to_run=("unrealircd" "anope")
            ;;
        "mail")
            local services_to_run=("postfix" "dovecot" "spamassassin")
            ;;
        "monitoring")
            local services_to_run=("cockpit" "netdata")
            ;;
        *)
            local services_to_run=("$service")
            ;;
    esac

    for target_service in "${services_to_run[@]}"; do
        SCRIPT="$SERVICES_DIR/$target_service/$action.sh"
        
        if [[ ! -f "$SCRIPT" ]]; then
            log_message "[ERROR] Script nicht gefunden: $SCRIPT"
            SKIPPED_SERVICES+=("$target_service")
            continue
        fi

        if [[ ! -x "$SCRIPT" ]]; then
            chmod +x "$SCRIPT"
        fi

        log_message "[ACTION] Starte $action fÃ¼r $target_service..."
        
        if $DRYRUN; then
            echo "[DRY-RUN] WÃ¼rde ausfÃ¼hren: $SCRIPT"
            SKIPPED_SERVICES+=("$target_service (dry-run)")
        else
            # FÃ¼hre Script aus und capture Exit-Code
            echo "AusfÃ¼hren: $SCRIPT"
            bash "$SCRIPT"
            local exit_code=$?
            
            if [ $exit_code -eq 0 ]; then
                log_message "[SUCCESS] $action fÃ¼r $target_service abgeschlossen"
                SUCCESSFUL_SERVICES+=("$target_service")
            else
                log_message "[ERROR] $action fÃ¼r $target_service fehlgeschlagen (Exit-Code: $exit_code)"
                FAILED_SERVICES+=("$target_service")
                
                # Frage bei Fehler nach Fortsetzung fÃ¼r einzelne Dienste
                if [[ "$original_service" != "all" ]]; then
                    read -p "âŒ Fehler bei $target_service. Trotzdem fortfahren? (j/N): " -n 1 -r
                    echo
                    if [[ ! $REPLY =~ ^[Jj]$ ]]; then
                        log_message "[INFO] Abbruch durch Benutzer nach Fehler in $target_service"
                        return 1
                    fi
                fi
            fi
        fi
    done
    return 0
}

service_submenu() {
    local action=$1
    clear
    echo "===== $action Menu ====="
    echo "1) All services"
    echo "2) MariaDB"
    echo "3) IRC (UnrealIRCd + Anope)"
    echo "4) Quasselcore"
    echo "5) Nextcloud"
    echo "6) MediaWiki"
    echo "7) Apache"
    echo "8) Teamspeak"
    echo "9) Vsftpd"
    echo "10) Monitoring (Cockpit + Netdata)"
    echo "11) Mailserver"
    echo "0) Back"
    read -p "Select a service: " choice

    # Arrays zurÃ¼cksetzen fÃ¼r neue Operation
    SUCCESSFUL_SERVICES=()
    FAILED_SERVICES=()
    SKIPPED_SERVICES=()

    case $choice in
        1) run_service_action "$action" "all" && print_summary "$action aller Dienste";;
        2) run_service_action "$action" "mariadb" && print_summary "$action MariaDB";;
        3) run_service_action "$action" "irc" && print_summary "$action IRC-Services";;
        4) run_service_action "$action" "quassel" && print_summary "$action Quasselcore";;
        5) run_service_action "$action" "nextcloud" && print_summary "$action Nextcloud";;
        6) run_service_action "$action" "mediawiki" && print_summary "$action MediaWiki";;
        7) run_service_action "$action" "apache" && print_summary "$action Apache";;
        8) run_service_action "$action" "teamspeak" && print_summary "$action Teamspeak";;
        9) run_service_action "$action" "vsftpd" && print_summary "$action Vsftpd";;
        10) run_service_action "$action" "monitoring" && print_summary "$action Monitoring";;
        11) run_service_action "$action" "mail" && print_summary "$action Mailserver";;
        0) main_menu ;;
        *) echo "Invalid option";;
    esac
}

main_menu() {
    # Firewall initialisieren beim Start
    if ! $DRYRUN; then
        check_firewall
    fi

    while true; do
        clear
        echo "=============================="
        echo "       Aetheron Setup"
        echo "       Version: $VERSION"
        echo "=============================="
        show_status
        echo ""
        echo "1) Install all services"
        echo "2) Install single service"
        echo "3) Reinstall service(s)"
        echo "4) Uninstall service(s)"
        echo "5) Wipe service(s)"
        echo "6) Test run (Dry-Run)"
        echo "7) Zeige letzte Zusammenfassung"
        echo "8) Script Version anzeigen"
        echo "9) Firewall Status anzeigen"
        echo "0) Exit"
        echo ""
        read -p "Select an option: " choice

        # Arrays zurÃ¼cksetzen fÃ¼r neue Operation
        SUCCESSFUL_SERVICES=()
        FAILED_SERVICES=()
        SKIPPED_SERVICES=()

        case $choice in
            1) run_service_action "install" "all" && print_summary "Installation aller Dienste";;
            2) service_submenu "install" ;;
            3) service_submenu "reinstall" ;;
            4) service_submenu "uninstall" ;;
            5) service_submenu "wipe" ;;
            6) DRYRUN=true; 
               echo "[*] Dry-run mode enabled"; 
               read -p "Press Enter to continue..." dummy;
               DRYRUN=false;;
            7) [ -f "$SUMMARY_LOG" ] && cat "$SUMMARY_LOG" || echo "Keine Zusammenfassung verfÃ¼gbar.";
               read -p "Press Enter to continue..." dummy;;
            8) echo "Aktuelle Version: $VERSION";
               read -p "Press Enter to continue..." dummy;;
            9) echo "Firewall Status:";
               sudo firewall-cmd --list-all;
               read -p "Press Enter to continue..." dummy;;
            0) echo "Exiting..."; exit 0;;
            *) echo "Invalid option";;
        esac
    done
}

# Start
main_menu
=== COMMON.SH ===
#!/bin/bash
# common.sh - Common functions for all service scripts
# Version: 1.00.04

VERSION="1.00.04"

# Service-Name aus Verzeichnis-Pfad extrahieren
get_service_name() {
    local full_path="$(dirname "$0")"
    echo "$(basename "$full_path")"
}

get_service_user() {
    local service=$(get_service_name)
    echo "$service"
}

get_service_home() {
    local service=$(get_service_name)
    echo "/home/$service"
}

# Funktion zum Erstellen von Service-Usern
create_service_user() {
    local user=$1
    local group=$2
    local home=$3

    if ! getent group "$group" > /dev/null; then
        sudo groupadd "$group"
        log_message "Group $group created"
    fi

    if ! id "$user" &>/dev/null; then
        sudo useradd -r -g "$group" -d "$home" -s /bin/bash "$user"
        sudo mkdir -p "$home"
        sudo chown "$user:$group" "$home"
        log_message "User $user created with home $home"
    fi
}

# Funktion zum Installieren von Paketen
install_package() {
    local name=$1
    local package=$2

    if ! pacman -Qi "$package" &> /dev/null; then
        sudo pacman -S --noconfirm "$package"
        log_message "Package $name installed"
    else
        log_message "Package $name already installed"
    fi
}

# Firewall-Funktionen fÃ¼r firewalld
open_port() {
    local port=$1
    local protocol=$2
    local description=$3

    # Port permanent hinzufÃ¼gen
    sudo firewall-cmd --permanent --add-port=$port/$protocol
    sudo firewall-cmd --reload
    log_message "Port $port/$protocol opened for $description"
}

close_port() {
    local port=$1
    local protocol=$2
    local description=$3

    # Port permanent entfernen
    sudo firewall-cmd --permanent --remove-port=$port/$protocol
    sudo firewall-cmd --reload
    log_message "Port $port/$protocol closed for $description"
}

# SSH Service explizit erlauben (wichtig fÃ¼r Public Key Auth)
ensure_ssh_access() {
    log_message "Ensuring SSH access (port 22) is enabled..."
    sudo firewall-cmd --permanent --add-service=ssh
    sudo firewall-cmd --reload
    log_message "SSH service enabled in firewall"
}

# Service-Funktionen fÃ¼r firewalld
open_service() {
    local service=$1
    local description=$2

    sudo firewall-cmd --permanent --add-service=$service
    sudo firewall-cmd --reload
    log_message "Service $service opened for $description"
}

close_service() {
    local service=$1
    local description=$2
     sudo firewall-cmd --permanent --remove-service=$service
    sudo firewall-cmd --reload
    log_message "Service $service closed for $description"
}

# Firewall Status prÃ¼fen
check_firewall() {
    if ! systemctl is-active --quiet firewalld; then
        log_message "âš ï¸  firewalld is not active. Starting and enabling..."
        sudo systemctl enable --now firewalld
    fi

    # Default Zone auf 'drop' oder 'block' setzen fÃ¼r maximale Sicherheit
    local default_zone=$(sudo firewall-cmd --get-default-zone)
    if [[ "$default_zone" != "drop" && "$default_zone" != "block" ]]; then
        log_message "âš ï¸  Setting default zone to 'drop' for better security..."
        sudo firewall-cmd --set-default-zone=drop
    fi

    # SSH Zugang sicherstellen
    ensure_ssh_access
}

# Funktion zum Aktivieren/Starten von Services
enable_and_start_service() {
    local service=$1

    sudo systemctl enable "$service"
    sudo systemctl start "$service"
    log_message "Service $service enabled and started"
}

# Funktion zum Docker Compose
run_docker_compose() {
    local service=$1
    local compose_file="${2:-docker-compose.yml}"

    # Umgebungsvariablen fÃ¼r User/GID setzen
    export UID=$(id -u $SERVICE_USER 2>/dev/null || echo 1000)
    export GID=$(id -g $SERVICE_GROUP 2>/dev/null || echo 1000)

    docker-compose -f "$compose_file" up -d
    log_message "Docker Compose started for $service"
}

# Funktion zum Log-Rotation Setup
setup_log_rotation() {
    local service=$1
    local log_path=$2

    # Logrotate-Konfiguration erstellen
    sudo tee /etc/logrotate.d/aetheron-$service << EOF
$log_path/*.log {
    daily
    missingok
    rotate 10
    compress
    delaycompress
    notifempty
    create 0640 khryon users
    sharedscripts
}
EOF
    log_message "Log rotation configured for $service (keep 10 versions)"
}

# Logging-Funktion KORRIGIERT
log_message() {
    local message="$1"
    local script_dir="$(dirname "$0")"
    local logfile="$script_dir/../../logs/$(basename "$0" .sh).log"
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $message" | tee -a "$logfile"
}

# Funktion zur Generierung eines starken Passworts
generate_strong_password() {
    local length=20
    local upper="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    local lower="abcdefghijklmnopqrstuvwxyz"
    local digits="0123456789"
    local special="!@#$%^&*()_+-=[]{}|;:,.<>?~"

    # Garantierte Zeichen (je 1x)
    local guaranteed_chars=$( \
        echo "${upper:$((RANDOM % ${#upper})):1}" \
        "${lower:$((RANDOM % ${#lower})):1}" \
        "${digits:$((RANDOM % ${#digits})):1}" \
        "${special:$((RANDOM % ${#special})):1}" \
        | tr -d ' ' \
    )

    # Restliche Zeichen (nur Buchstaben und Zahlen)
    local all_chars_no_special="${upper}${lower}${digits}"
    local remaining_chars=""
    for ((i=0; i<16; i++)); do
        remaining_chars+="${all_chars_no_special:$((RANDOM % ${#all_chars_no_special})):1}"
    done

    # Kombiniere und mische
    local combined_chars="${guaranteed_chars}${remaining_chars}"
    local password=$(echo "$combined_chars" | fold -w1 | shuf | tr -d '\n')

    echo "$password"
}
